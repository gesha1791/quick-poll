# <a href="http://git.foxminded.com.ua/gesha17/quick-poll">Chapter 4</a>

#### 1.	Основные 4 соглашения (принципа) в дизайне рест эндпоинтов.
Использование базового URI, это как точка входя для нашего API (localhost:8080. Второе , использование существительного во множественном числе (/users, /options, /votes). Третье иерархия рерурсов к примеру (localhost:8080/users/{userId}/blogs/{blogId}/. Четвертое параметры запроса.
#### 2.	Получая требования к SaaS-приложению через какие неотъемлемые этапы анализа необходимо пройти рест-сервисному приложению?
Первое нам нужно определить правильно ресурсы. Анализируем требования и извлекаем существительные (чем-то похоже на проектирование БД). Не все существительные являются ресурсами. Получаем доступ к ресурсам.
Второе, определяем формат представления ресурсов. Это в основном зависит от пользователя (де факто JSON).  Получаем ответ в формате json.
Третье, определить интуитивно понятные и простые конечные точки. Пишем понятные URI.
Четвертое правильно подобрать HTTP глаголы (verb/action) до конечных точек. Интуитивно понятное действие с URI, к примеру  GET localhost:8080/polls получим все polls , потому что id не указан.
#### 3.	Ответ выше.
#### 4.	Подумать и привести пару возможных негативных последствий плохого REST API design.
К примеру, если определить слишком много ресурсов, то придется делать лишние запросы, что будет перегружать сервер. Так же можно не правильно использовать глаголы, к примеру для частичного обновления ресурса можно использовать PATCH. Запросы PUT используются вместо POST и наоборот.
#### 5.	Какие ресурсы есть/были_идентифицированны в QuickPoll приложении?
Polls, votes, computeResult, users (позже будет идентифицирован)
#### 6.	С какими репрезентациями этих ресурсов мы работаем?
Мы работаем с polls (опросы), votes(голоса), computeResult (для этого ресурса требуются данные других ресурсов, на  основе которых работает этот ресурс)
#### 7.	Имея ТЗ, как отличить существительные которые вероятно будут представлены как ресурсы от тех которые скорее не будут? Откуда могут появиться ресурсы не представленные в задании существительными 1-в-1?
Все зависит от ТЗ. На примере нашего приложения, если нам не нужно выполнять никаких манипуляций с options , то мы можем их представить как коллекцию в другом ресурсе, в нашем примере Votes.
Эти ресурсы появляются когда нужно с ресурсами произвести определенные операции и вывести результат. В нашем примере computeResult, который подсчитывает в данном опросе голоса определенного option и выводит их в отсортированом порядке.
#### 8.	Для каких ситуаций обычно достаточно 1 формата репрезентации ресурсов?
Преимущества JSON перед XML?(опционально)
Некоторые службы поддерживают только json, тогда предпочтительно использовать этот формат. Все зависит от клиентов и аудитории нашего API.
Код удобно читается, интуитивно понятна схема, легко создаются объекты, очень распространен, поддерживается многими редакторами.
#### 9.	Перечислить типы значений в JSON.
Boolean (true or false), число (int or flaot), String , null, array and object.
#### 10.	(optional) Почему коллекция объектов помеченная @OrderBy в таблице не отсортирована, а в объекте отсортирована?
Не знаю верно или нет, это мои догадки, потому что аннотация стоит на уровне слоя модель.
#### 11.	Типично DAO сохраняет данные в БД. Будет ли класс по прежнему DAO если он сохраняет данные во внешней legacy системе?
Dao доступ к БД или любому другому источнику данных. Да будет.

#### 12.	Написать endpoint для получения всех, создать Spring MVC контроллер и репозиторий для сущности Mouse {id: long, name: String} в Spring Data.

Endpoint: localhost:8080/mouses/
Repository: public interface MouseRepository extends CrudRepository<Mouse, Long>{}
Controller:
@Autowired
MouseRepository mouseRepository

@RequestMapping(value = “/mouses”, method = RequestMethod.GET)
public ResponseEntity<Iterable<Mouse>> getAllMouses(){
Iterable<Mouse> allMouses = mouseRepository.findAll();
return new ResponseEntity<>(allMouses, HttpStatus.ОК);
}

#### 13.	В каких случаях мы будем использовать ResponseEntity вместо String в качестве возвращаемого значения метода помеченного @RequestMapping?
ResponseEntity представляет весь HTTP-ответ: код состояния, хедер и тело. Из-за этого мы можем использовать его для полной настройки HTTP-ответа. ResponseEntity является универсальным типом. В результате мы можем использовать любой тип в качестве тела ответа.
Во всех случаях когда вернуть нужно не строку.
#### 14.	Что мы помечаем @RequestBody и зачем? Как называется заголовок по которому спринг определяет какой месседж конвертер использовать?
Указывает на то что при запросе передается тело, которое нужно заполнить. Например при создании нового объекта, мы указываем в теле запроса данные, с помощью которых создастся новый объект. Заголовок если не ошибаюсь называется “Content-Type”
#### 15.	При создании нового экземпляра некого ресурса, как называется заголовок в котором мы должны вернуть URL на новосозданный инстанс?
Location
#### 16.	Что такое DTO и почему мы создавали некоторые из них учитывая что классы представляющие данные (доменную модель) вполне себе присутствуют и лежат в пакете ua.com.foxminded.quickpoll.domain, почему просто не добавили туда класс?
Я думаю что эти классы основываются на классах с доменов области, эти данные мы не сохраняем в БД, они являются как бы временными, используются для удобства передачи данных клиенту или для вычислений…
#### 17.	 (опционально) Отличия javax.inject.Inject от @Autowired.
@Inject это Java EE , @Autowired это Spring
#### 18.	 Как добавить возможность использовать @Inject аннотацию в проект? Привести groupId, artifactId, версию, скоуп.
<proupId>javax.inject</groupId>
<artifactId>javax.inject</artifactId>
<version>1</version>
<scope>compile</scope>
#### 19.	 Лейеры приложения (с именами).
Domain, exceptions, controller, repository, service, web
        - Что дает такое разделение.
Многоуровневый подход обеспечивает четкое разделение задач, облегчая создание и обслуживание приложений. Каждый слой взаимодействует со слоем ниже, используя четко определенный контракт. Пока контракт сохраняется, можно менять базовые реализации без какого-либо влияния на всю систему.
           - На каком уровне живет:
             - конвертация exceptions в http codes (Exceptions)
             - обработка пользовательского запроса в соответствии с бизнес правилами (Controller)
           - * удовлетворение специфических use-case-ов/потребностей клиентов различных платформ, (Service)
             - CRUD операции с сущностями, (Repository)
             - * управление транзакциями между несколькими источниками данных (Servise возможно)
             - валидация параметров запроса? (Controller)
